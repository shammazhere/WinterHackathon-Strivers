<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>PocketFlow D3 Runtime</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body { margin: 0; background: #0d1117; overflow: hidden; color: #c9d1d9; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif; }
        #canvas { width: 100vw; height: 100vh; }
        .node circle { stroke: #30363d; stroke-width: 1.5px; fill: #1f6feb; transition: all 0.2s; }
        .node text { fill: #8b949e; font-size: 10px; font-weight: 400; }
        .link { stroke: #30363d; stroke-opacity: 0.3; stroke-width: 1px; fill: none; }
        
        /* Active states */
        .node.active circle { fill: #39d353; r: 12; filter: drop-shadow(0 0 8px #39d353); }
        .node.active text { fill: #fff; font-weight: bold; }
        .link.active { stroke: #39d353; stroke-opacity: 1; stroke-width: 2px; }
    </style>
</head>
<body>
    <svg id="canvas"></svg>

    <script>
        const svg = d3.select("#canvas");
        const width = window.innerWidth;
        const height = window.innerHeight;
        const g = svg.append("g");

        const simulation = d3.forceSimulation()
            .force("link", d3.forceLink().id(d => d.id).distance(100))
            .force("charge", d3.forceManyBody().strength(-300))
            .force("center", d3.forceCenter(width / 2, height / 2));

        const ws = new WebSocket('ws://localhost:8080');

        ws.onmessage = (event) => {
            const msg = JSON.parse(event.data);
            
            if (msg.type === 'INIT_MAP') {
                updateGraph(msg.data.nodes, msg.data.edges);
            } else if (msg.type === 'CALL') {
                triggerAnimation(msg.nodeId);
            }
        };

        function updateGraph(nodes, edges) {
            // Filter edges to only show connections where BOTH ends exist in our nodes
            const validEdges = edges.filter(e => 
                nodes.some(n => n.id === e.from) && 
                nodes.some(n => n.label === e.to)
            ).map(e => ({
                source: e.from,
                target: nodes.find(n => n.label === e.to).id
            }));

            const link = g.append("g")
                .selectAll("line")
                .data(validEdges)
                .join("line")
                .attr("class", "link");

            const node = g.append("g")
                .selectAll(".node")
                .data(nodes)
                .join("g")
                .attr("class", "node")
                .attr("id", d => "node-" + btoa(d.id).replace(/=/g, ''));

            node.append("circle").attr("r", 6);
            node.append("text").attr("dx", 10).attr("dy", 4).text(d => d.label);

            simulation.nodes(nodes).on("tick", () => {
                link.attr("x1", d => d.source.x).attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x).attr("y2", d => d.target.y);
                node.attr("transform", d => `translate(${d.x},${d.y})`);
            });

            simulation.force("link").links(validEdges);
        }

        function triggerAnimation(nodeId) {
            const safeId = "node-" + btoa(nodeId).replace(/=/g, '');
            const element = d3.select("#" + safeId);

            if (element.empty()) return;

            // 1. Light up the node
            element.classed("active", true);

            // 2. Light up any outgoing links (the "flow" effect)
            g.selectAll(".link")
                .filter(d => d.source.id === nodeId)
                .classed("active", true)
                .transition()
                .duration(1000)
                .on("end", function() { d3.select(this).classed("active", false); });

            // 3. Turn off the node after a delay
            setTimeout(() => {
                element.classed("active", false);
            }, 800);
        }
    </script>
</body>
</html>